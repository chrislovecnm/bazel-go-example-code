

## Dependencies

We use the following dependencies for the example.

- go: https://go.dev/doc/install
- gcc: use your systems package manager
- bazelisk: https://github.com/bazelbuild/bazelisk#installation

Technically we do not need the go binary installed, but we are going to use
`cobra-cli` to generate some project code.  We did not want to add the 
extract work in bazel to run the binary using bazel.

## The project

We are going to create a small example project first using go.  As
we mentioned you do not need to use go directly at all, when using bazel.
But to get a "easy" jump start we wanted to quickly generate some code.

The project is going to consist of a simple cli program that rolls a
random number or generates a random word.

## Generate the project framework

First create a git repository to store you work.  Next use go
to install cobra-cli.  The cobra-cli binary is provided by the spf13/cobra
project for the intial generation of cli code:
https://github.com/spf13/cobra-cli/blob/main/README.md.

For our example we are using github.com/chrislovecnm/bazel-go-example-code.

First use go mod and init the code example.

```
$ go mod init github.com/chrislovecnm/bazel-go-example-code
```

Next use cobra-cli to create go root, rool and word files.

```
$ ~/Workspace/bin/cobra-cli init -a "Chris Love chris@lionkube.com" --license apache
$ ~/Workspace/bin/cobra-cli add roll -a "Chris Love chris@lionkube.com" --license apache
$ ~/Workspace/bin/cobra-cli add word -a "Chris Love chris@lionkube.com" --license apache
```

You will now have the following files:

```
├── cmd
│   ├── roll.go
│   ├── root.go
│   └── word.go
├── go.mod
├── go.sum
└── main.go
```

Let's add a couple of directories:

```
mkdir -p pkg/{word,roll}
```

Inside of those directories we can add roll_dice.go and generate_word.go files.
You will end up with the following file structure:

```
├── cmd
│   ├── roll.go
│   ├── root.go
│   └── word.go
├── go.mod
├── go.sum
├── main.go
└── pkg
    ├── roll
    │   └── roll_dice.go
    └── word
        └── generate_word.go
```

In the roll_dice.go file add the following code:


```
package roll

import "fmt"

func Roll() {
        fmt.Println("roll dice")
}
```

In the generate_word.go file add the the following code:

```
package word

import "fmt"

func GenerateWord() {
        fmt.Println("GenerateWord")
}
```

Next add files to git and push there contents to your remote repo.

## Go and Bazel

In order to use go and bazel we are going to use rules_go and bazel-gazelle.

- https://github.com/bazelbuild/rules_go
- https://github.com/bazelbuild/bazel-gazelle

rules_go is the set of bazel rules that allows for the various functionality including
dependency management and go compilations. A bazel rule defines a series of actions that 
Bazel performs on inputs to produce a set of outputs, which are referenced in 
providers returned by the rule's implementation function.

Gazelle is a build file generator for Bazel projects. It can create new BUILD.bazel files
for a project that follows language conventions, and it can update existing build files to 
include new sources, dependencies, and options. Gazelle natively supports Go and protobuf, 
haskell, java, javascript. A user can extend Gazelle to support new lanaguages and other
generation rules.

So we define rules_go to build our code, and we use gazelle to manage our BUILD.bazel files.

If you are not familiar with BUILD.bazel files or WORKSPACE files take a look at:
https://bazel.build/concepts/build-files

Next let's create our WORKSPACE file so that bazel knows it is using rules_go and gazelle.

## Create WORKSPACE file

We now need to create the bazel WORKSPACE file.
This is documented here: https://github.com/bazelbuild/bazel-gazelle#running-gazelle-with-bazel

```
# use http_archive to download bazel rules_go
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "io_bazel_rules_go",
    sha256 = "099a9fb96a376ccbbb7d291ed4ecbdfd42f6bc822ab77ae6f1b5cb9e914e94fa",
    urls = [
        "https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.35.0/rules_go-v0.35.0.zip",
        "https://github.com/bazelbuild/rules_go/releases/download/v0.35.0/rules_go-v0.35.0.zip",
    ],
)

# use http_archive to download bazel_gazelle dependency
http_archive(
    name = "bazel_gazelle",
    sha256 = "efbbba6ac1a4fd342d5122cbdfdb82aeb2cf2862e35022c752eaddffada7c3f3",
    urls = [
        "https://mirror.bazel.build/github.com/bazelbuild/bazel-gazelle/releases/download/v0.27.0/bazel-gazelle-v0.27.0.tar.gz",
        "https://github.com/bazelbuild/bazel-gazelle/releases/download/v0.27.0/bazel-gazelle-v0.27.0.tar.gz",
    ],
)

# load bazel and gazelle rules
load("@io_bazel_rules_go//go:deps.bzl", "go_register_toolchains", "go_rules_dependencies")
load("@bazel_gazelle//:deps.bzl", "gazelle_dependencies")

############################################################
# Define your own dependencies here using go_repository.
# Else, dependencies declared by rules_go/gazelle will be used.
# The first declaration of an external repository "wins".
############################################################

# we are going to store the go dependecy definitions
# in a different file "deps.bzl". We can include those 
# definitions in this file, but it gets quite verbose.
load("//:deps.bzl", "go_dependencies")

# Next we initialize the tool chains

# gazelle:repository_macro deps.bzl%go_dependencies
go_dependencies()

go_rules_dependencies()

# We define the version of go that this project uses
go_register_toolchains(version = "1.19.1")

gazelle_dependencies()
```

The above WORKSPACE file contains specific version numbers for rules_go and gazelle.  Refer to the 
gazelle site to use the latest versions.  Also update the  `go_register_toolchains(version = "1.19.1")`
to the version that you would like to use of go.

Next we need to a BUILD file in the root project directory.

## Create intial BUILD file

Here are the contents of the BUILD file:

```
# Load the gazelle rule
load("@bazel_gazelle//:def.bzl", "gazelle")

# The following comment defines the import path that corresponds to the repository root directory.
# This is a critical definition, and if you mess this up all of the BUILD file generation 
# will have errors.

# Modify the name to your project name in your git repository.

# gazelle:prefix github.com/chrislovecnm/bazel-go-example-code
gazelle(name = "gazelle")
```
Again the `gazelle:prefix` is critical.  If the prefix is not named correctly
you will get code importing incorrectly. For instance you will get BUILD.bazel
in the root directory importing a file starting with the `@` prefix.


Now we have a WORKSPACE and BUILD.bazel files.  You directory should resemble the
following.

```
├── BUILD.bazel
├── WORKSPACE
├── cmd
│   ├── roll.go
│   ├── root.go
│   └── word.go
├── go.mod
├── go.sum
├── main.go
└── pkg
    ├── roll
    │   ├── BUILD.bazel
    │   └── roll_dice.go
    └── word
        ├── BUILD.bazel
        └── generate_word.go
```

Next we will use bazel to run the gazelle target.

### Run the gazelle commands

As we previously mentioned we use bazel to run gazelle, and 
gazelle manages the BUILD.bazel files for us.

We are using bazelisk to manage and run bazel, but we will
typically say "run bazel" instead of run "bazelisk".  

Run the following command to update the BUILD.bazel file.  
The following commands will also generate the other BUILD.bazel
files that are required.

```
$ bazelisk run //:gazelle
$ bazelisk run //:gazelle-update-repos
```

You now have the following files:

```
├── BUILD.bazel
├── CREATE.adoc
├── LICENSE
├── WORKSPACE
├── cmd
│   ├── BUILD.bazel
│   ├── roll.go
│   ├── root.go
│   └── word.go
├── deps.bzl
├── go.mod
├── go.sum
├── main.go
└── pkg
    ├── roll
    │   ├── BUILD.bazel
    │   └── roll_dice.go
    └── word
        ├── BUILD.bazel
        └── generate_word.go
```

Next we will modify the root.go and word.go files.

## Using the files under pkg

Now we want to add in the roll and word files under the pkg directory.

```
├── cmd
│   ├── roll.go
└── pkg
    ├── roll
    │   └── roll_dice.go
```

Edit roll.go under the cmd folder and add an import to roll_dice.

You will now have:

```
import (
    "fmt"

    "github.com/chrislovecnm/bazel-go-example-code/pkg/roll"
    "github.com/spf13/cobra"
)
```

Then call `roll.Roll()` after the `fmt.Println` statement. This will give you:

```
   Run: func(cmd *cobra.Command, args []string) {
       fmt.Println("roll called")
       roll.Roll()
   },
```

We now need to update the BAZEL.build files, and the easiest way to do this is to run gazelle again.

Execute the following command

```
$ bazelisk run //:gazelle
```

We can now use bazel to run the binary again:

```
$ bazelisk run //:bazel-go-example-code roll

```

The above command builds the binary and executes it.  The following
is an example of the output from the run command.

```
INFO: Analyzed target //:bazel-go-example-code (1 packages loaded, 6 targets configured).
INFO: Found 1 target...
Target //:bazel-go-example-code up-to-date:
  bazel-bin/bazel-go-example-code_/bazel-go-example-code
INFO: Elapsed time: 0.316s, Critical Path: 0.16s
INFO: 3 processes: 1 internal, 2 linux-sandbox.
INFO: Build completed successfully, 3 total actions
INFO: Build completed successfully, 3 total actions
roll called
roll dice
```

Running the gazelle target modified the Build.bazel file under the cmd directory.  Here is the diff.

```
diff --git a/cmd/BUILD.bazel b/cmd/BUILD.bazel
index ac66183..9033b86 100644
--- a/cmd/BUILD.bazel
+++ b/cmd/BUILD.bazel
@@ -9,5 +9,8 @@ go_library(
     ],
     importpath = "github.com/chrislovecnm/bazel-go-example-code/cmd",
     visibility = ["//visibility:public"],
-    deps = ["@com_github_spf13_cobra//:cobra"],
+    deps = [
+        "//pkg/roll",
+        "@com_github_spf13_cobra//:cobra",
+    ],
 )
```

The line was added inside of the deps stanza that points to the package where roll.go resides.

We can the call to the `GenerateWord()` func inside of cmd/word.go.

Here is the diff afterwards.

```
diff --git a/cmd/word.go b/cmd/word.go
index d7d00bb..cddc748 100644
--- a/cmd/word.go
+++ b/cmd/word.go
@@ -1,12 +1,12 @@
 /*
 Copyright © 2022 NAME HERE <EMAIL ADDRESS>
-
 */
 package cmd

 import (
        "fmt"

+       "github.com/chrislovecnm/bazel-go-example-code/pkg/word"
        "github.com/spf13/cobra"
 )

@@ -22,6 +22,7 @@ This application is a tool to generate the needed files
 to quickly create a Cobra application.`,
        Run: func(cmd *cobra.Command, args []string) {
                fmt.Println("word called")
+               word.GenerateWord()
        },
 }
```

We added the import and the call to `word.GenerateWord()`. Again we can run gazelle 
add the new dep to the BUILD.bazel file. 

Now we have BUILD.bazel updated.

```
diff --git a/cmd/BUILD.bazel b/cmd/BUILD.bazel
index ac66183..891b0e1 100644
--- a/cmd/BUILD.bazel
+++ b/cmd/BUILD.bazel
@@ -9,5 +9,9 @@ go_library(
     ],
     importpath = "github.com/chrislovecnm/bazel-go-example-code/cmd",
     visibility = ["//visibility:public"],
-    deps = ["@com_github_spf13_cobra//:cobra"],
+    deps = [
+        "//pkg/roll",
+        "//pkg/word",
+        "@com_github_spf13_cobra//:cobra",
+    ],
 )
```

We can use bazel to execute the binary with the new changes.

```
$ bazelisk run //:bazel-go-example-code word
INFO: Analyzed target //:bazel-go-example-code (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //:bazel-go-example-code up-to-date:
  bazel-bin/bazel-go-example-code_/bazel-go-example-code
INFO: Elapsed time: 0.107s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Build completed successfully, 1 total action
word called
GenerateWord
```

## Adding external dependency


To create our random work generator we are going to use babble, which is located here: 
https://github.com/tjarratt/babble. The babble code On Linux uses "/usr/share/dicts/words" file, and you can use 
the package manager to install wamerican or wbritish.

Edit generate_word.go to add the call to babble.

```
└── pkg
    └── word
        └── generate_word.go
```

We need to add the import to babble and call the babble func. Here is the diff after the updates.
I also cleaned up the Println to add some clarity.

```
diff --git a/pkg/word/generate_word.go b/pkg/word/generate_word.go
index 312a267..37215cf 100644
--- a/pkg/word/generate_word.go
+++ b/pkg/word/generate_word.go
@@ -1,7 +1,12 @@
 package word

-import "fmt"
+import (
+       "fmt"
+
+       "github.com/tjarratt/babble"
+)

 func GenerateWord() {
+       fmt.Println("GenerateWord called")
+       fmt.Println(babble.NewBabbler().Babble())
 }
```

Once that is done, we need to run go mod to update the projects 
dependencies.

```
$ bazel run @go_sdk//:bin/go -- mod tidy
```

Keeping go.mod updated allows us to either use go directly or bazel to build
and run the code.

We now need to update the Bazel import, and the easiest way to do this is to run gazelle again.

```
$ bazelisk run //:gazelle-update-repos
$ bazelisk run //:gazelle
```

The first bazel command updates deps.bzl file. The second command
updates the BUILD.bazel file in pkg/word.  Below is the diff of the 
updates.

```
diff --git a/pkg/word/BUILD.bazel b/pkg/word/BUILD.bazel
index c974b0b..e5c0b28 100644
--- a/pkg/word/BUILD.bazel
+++ b/pkg/word/BUILD.bazel
@@ -5,4 +5,5 @@ go_library(
     srcs = ["generate_word.go"],
     importpath = "github.com/chrislovecnm/bazel-go-example-code/pkg/word",
     visibility = ["//visibility:public"],
+    deps = ["@com_github_tjarratt_babble//:babble"],
 )

```

You can see the deps is now updated and points to the external repo "@com_github_tjarratt_babble//:babble".

This repo is defined in deps.bzl file in the following go_repository stanza.

```
go_repository(
    name = "com_github_tjarratt_babble",
    importpath = "github.com/tjarratt/babble",
    sum = "h1:j8whCiEmvLCXI3scVn+YnklCU8mwJ9ZJ4/DGAKqQbRE=",
    version = "v0.0.0-20210505082055-cbca2a4833c1",
)
```

We can now run our binary and see the changes.

```
$ bazelisk run //:bazel-go-example-code word
INFO: Analyzed target //:bazel-go-example-code (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //:bazel-go-example-code up-to-date:
  bazel-bin/bazel-go-example-code_/bazel-go-example-code
INFO: Elapsed time: 0.257s, Critical Path: 0.15s
INFO: 3 processes: 1 internal, 2 linux-sandbox.
INFO: Build completed successfully, 3 total actions
INFO: Build completed successfully, 3 total actions
word called
GenerateWord called
Rheingau-nightclothes
```

To recap what we have done.  We have modified our code to use the babble go code which lives on 
github.  We then use bazel to run go mod, which updates go.mod file. Next we ran gazelle-update-repos and gazelle
with bazel. The first bazel alias updated the deps.bzl file with the external dependency, and the gazelle target 
updated the deps section in pkg/word/BUILD.bazel.  Bazel is then able to download the external dependency
and use that dependency when our example go program is compiled.


## Testing



